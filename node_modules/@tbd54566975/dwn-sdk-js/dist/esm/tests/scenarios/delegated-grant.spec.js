var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import chaiAsPromised from 'chai-as-promised';
import emailProtocolDefinition from '../vectors/protocol-definitions/email.json' assert { type: 'json' };
import sinon from 'sinon';
import threadRoleProtocolDefinition from '../vectors/protocol-definitions/thread-role.json' assert { type: 'json' };
import chai, { expect } from 'chai';
import { base64url } from 'multiformats/bases/base64';
import { DataStream } from '../../src/utils/data-stream.js';
import { DidKeyResolver } from '../../src/did/did-key-resolver.js';
import { DidResolver } from '../../src/did/did-resolver.js';
import { Dwn } from '../../src/dwn.js';
import { DwnErrorCode } from '../../src/core/dwn-error.js';
import { Jws } from '../../src/utils/jws.js';
import { RecordsWrite } from '../../src/interfaces/records-write.js';
import { TestDataGenerator } from '../utils/test-data-generator.js';
import { TestStores } from '../test-stores.js';
import { Time } from '../../src/utils/time.js';
import { DwnInterfaceName, DwnMethodName, PermissionsGrant, RecordsDelete, RecordsQuery, RecordsRead } from '../../src/index.js';
chai.use(chaiAsPromised);
export function testDelegatedGrantScenarios() {
    describe('delegated grant tests', () => __awaiter(this, void 0, void 0, function* () {
        let didResolver;
        let messageStore;
        let dataStore;
        let eventLog;
        let dwn;
        // important to follow the `before` and `after` pattern to initialize and clean the stores in tests
        // so that different test suites can reuse the same backend store for testing
        before(() => __awaiter(this, void 0, void 0, function* () {
            didResolver = new DidResolver([new DidKeyResolver()]);
            const stores = TestStores.get();
            messageStore = stores.messageStore;
            dataStore = stores.dataStore;
            eventLog = stores.eventLog;
            dwn = yield Dwn.create({ didResolver, messageStore, dataStore, eventLog });
        }));
        beforeEach(() => __awaiter(this, void 0, void 0, function* () {
            sinon.restore(); // wipe all previous stubs/spies/mocks/fakes
            // clean up before each test rather than after so that a test does not depend on other tests to do the clean up
            yield messageStore.clear();
            yield dataStore.clear();
            yield eventLog.clear();
        }));
        after(() => __awaiter(this, void 0, void 0, function* () {
            yield dwn.close();
        }));
        it('should only allow entity invoking a valid delegated grant to write', () => __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            // scenario:
            // 1. Alice creates a delegated grant for Device X and Device Y,
            // 2. Device X and Y can both use their grants to write a message to Bob's DWN as Alice
            // 3. Messages written by device X and Y should be considered to have been authored by Alice
            // 4. Carol should not be able to write a message as Alice using Device X's delegated grant
            const alice = yield DidKeyResolver.generate();
            const deviceX = yield DidKeyResolver.generate();
            const deviceY = yield DidKeyResolver.generate();
            const bob = yield DidKeyResolver.generate();
            const carol = yield DidKeyResolver.generate();
            // Bob has the email protocol installed
            const protocolDefinition = emailProtocolDefinition;
            const protocol = protocolDefinition.protocol;
            const protocolsConfig = yield TestDataGenerator.generateProtocolsConfigure({
                author: bob,
                protocolDefinition
            });
            const protocolConfigureReply = yield dwn.processMessage(bob.did, protocolsConfig.message);
            expect(protocolConfigureReply.status.code).to.equal(202);
            // Alice creates a delegated grant for device X and device Y
            const scope = {
                interface: DwnInterfaceName.Records,
                method: DwnMethodName.Write,
                protocol
            };
            const deviceXGrant = yield PermissionsGrant.create({
                delegated: true,
                dateExpires: Time.createOffsetTimestamp({ seconds: 100 }),
                description: 'Allow to write to message protocol',
                grantedBy: alice.did,
                grantedTo: deviceX.did,
                grantedFor: alice.did,
                scope: scope,
                signer: Jws.createSigner(alice)
            });
            const deviceYGrant = yield PermissionsGrant.create({
                delegated: true,
                dateExpires: Time.createOffsetTimestamp({ seconds: 100 }),
                description: 'Allow to write to message protocol',
                grantedBy: alice.did,
                grantedTo: deviceY.did,
                grantedFor: alice.did,
                scope: scope,
                signer: Jws.createSigner(alice)
            });
            // generate a `RecordsWrite` message from device X and write to Bob's DWN
            const deviceXData = new TextEncoder().encode('message from device X');
            const deviceXDataStream = DataStream.fromBytes(deviceXData);
            const messageByDeviceX = yield RecordsWrite.create({
                signer: Jws.createSigner(deviceX),
                delegatedGrant: deviceXGrant.asDelegatedGrant(),
                protocol,
                protocolPath: 'email',
                schema: protocolDefinition.types.email.schema,
                dataFormat: protocolDefinition.types.email.dataFormats[0],
                data: deviceXData
            });
            const deviceXWriteReply = yield dwn.processMessage(bob.did, messageByDeviceX.message, deviceXDataStream);
            expect(deviceXWriteReply.status.code).to.equal(202);
            // verify the message by device X got written to Bob's DWN, AND Alice is the logical author
            const recordsQueryByBob = yield TestDataGenerator.generateRecordsQuery({
                author: bob,
                filter: { protocol }
            });
            const bobRecordsQueryReply = yield dwn.processMessage(bob.did, recordsQueryByBob.message);
            expect(bobRecordsQueryReply.status.code).to.equal(200);
            expect((_a = bobRecordsQueryReply.entries) === null || _a === void 0 ? void 0 : _a.length).to.equal(1);
            const fetchedDeviceXWriteEntry = bobRecordsQueryReply.entries[0];
            expect(fetchedDeviceXWriteEntry.encodedData).to.equal(base64url.baseEncode(deviceXData));
            const fetchedDeviceXWrite = yield RecordsWrite.parse(fetchedDeviceXWriteEntry);
            expect(fetchedDeviceXWrite.author).to.equal(alice.did);
            // generate a new message by device Y updating the existing record device X created, and write to Bob's DWN
            const deviceYData = new TextEncoder().encode('message from device Y');
            const deviceYDataStream = DataStream.fromBytes(deviceYData);
            const messageByDeviceY = yield RecordsWrite.createFrom({
                recordsWriteMessage: fetchedDeviceXWrite.message,
                data: deviceYData,
                signer: Jws.createSigner(deviceY),
                delegatedGrant: deviceYGrant.asDelegatedGrant(),
            });
            const deviceYWriteReply = yield dwn.processMessage(bob.did, messageByDeviceY.message, deviceYDataStream);
            expect(deviceYWriteReply.status.code).to.equal(202);
            // verify the message by device Y got written to Bob's DWN, AND Alice is the logical author
            const bobRecordsQueryReply2 = yield dwn.processMessage(bob.did, recordsQueryByBob.message);
            expect(bobRecordsQueryReply2.status.code).to.equal(200);
            expect((_b = bobRecordsQueryReply2.entries) === null || _b === void 0 ? void 0 : _b.length).to.equal(1);
            const fetchedDeviceYWriteEntry = bobRecordsQueryReply2.entries[0];
            expect(fetchedDeviceYWriteEntry.encodedData).to.equal(base64url.baseEncode(deviceYData));
            const fetchedDeviceYWrite = yield RecordsWrite.parse(fetchedDeviceYWriteEntry);
            expect(fetchedDeviceYWrite.author).to.equal(alice.did);
            // Verify that Carol cannot write a chat message as Alice by invoking the Device X's grant
            const messageByCarolAsAlice = new TextEncoder().encode('Message from Carol pretending to be Alice');
            const writeByCarolAsAlice = yield RecordsWrite.create({
                signer: Jws.createSigner(carol),
                delegatedGrant: deviceXGrant.asDelegatedGrant(),
                protocol,
                protocolPath: 'email',
                schema: protocolDefinition.types.email.schema,
                dataFormat: protocolDefinition.types.email.dataFormats[0],
                data: messageByCarolAsAlice
            });
            const carolWriteReply = yield dwn.processMessage(carol.did, writeByCarolAsAlice.message, DataStream.fromBytes(messageByCarolAsAlice));
            expect(carolWriteReply.status.code).to.equal(400);
            expect(carolWriteReply.status.detail).to.contain(DwnErrorCode.RecordsValidateIntegrityGrantedToAndSignerMismatch);
        }));
        it('should only allow entity invoking a valid delegated grant to read or query', () => __awaiter(this, void 0, void 0, function* () {
            var _c, _d, _e, _f;
            // scenario:
            // 1. Alice creates a delegated grant for device X,
            // 2. Bob starts a chat thread with Alice on his DWN
            // 3. device X should be able to read the chat thread
            // 4. Carol should not be able to read the chat thread using device X's delegated grant
            const alice = yield DidKeyResolver.generate();
            const deviceX = yield DidKeyResolver.generate();
            const bob = yield DidKeyResolver.generate();
            const carol = yield DidKeyResolver.generate();
            // Bob has the chat protocol installed
            const protocolDefinition = threadRoleProtocolDefinition;
            const protocol = threadRoleProtocolDefinition.protocol;
            const protocolsConfig = yield TestDataGenerator.generateProtocolsConfigure({
                author: bob,
                protocolDefinition
            });
            const protocolsConfigureReply = yield dwn.processMessage(bob.did, protocolsConfig.message);
            expect(protocolsConfigureReply.status.code).to.equal(202);
            // Bob starts a chat thread
            const threadRecord = yield TestDataGenerator.generateRecordsWrite({
                author: bob,
                protocol: protocolDefinition.protocol,
                protocolPath: 'thread',
            });
            const threadRoleReply = yield dwn.processMessage(bob.did, threadRecord.message, threadRecord.dataStream);
            expect(threadRoleReply.status.code).to.equal(202);
            // Bob adds Alice as a participant in the thread
            const participantRoleRecord = yield TestDataGenerator.generateRecordsWrite({
                author: bob,
                recipient: alice.did,
                protocol: protocolDefinition.protocol,
                protocolPath: 'thread/participant',
                contextId: threadRecord.message.contextId,
                parentId: threadRecord.message.recordId,
                data: new TextEncoder().encode('Alice is my friend'),
            });
            const participantRoleReply = yield dwn.processMessage(bob.did, participantRoleRecord.message, participantRoleRecord.dataStream);
            expect(participantRoleReply.status.code).to.equal(202);
            // Bob writes a chat message in the thread
            const chatRecord = yield TestDataGenerator.generateRecordsWrite({
                author: bob,
                protocol: protocolDefinition.protocol,
                protocolPath: 'thread/chat',
                contextId: threadRecord.message.contextId,
                parentId: threadRecord.message.recordId,
            });
            const chatRecordReply = yield dwn.processMessage(bob.did, chatRecord.message, chatRecord.dataStream);
            expect(chatRecordReply.status.code).to.equal(202);
            // Alice creates a delegated grant for device X to act as Alice.
            const scope = {
                interface: DwnInterfaceName.Records,
                method: DwnMethodName.Write,
                protocol
            };
            const grantToDeviceX = yield PermissionsGrant.create({
                delegated: true,
                dateExpires: Time.createOffsetTimestamp({ seconds: 100 }),
                description: 'Allow device X to write as me in chat protocol',
                grantedBy: alice.did,
                grantedTo: deviceX.did,
                grantedFor: alice.did,
                scope: scope,
                signer: Jws.createSigner(alice)
            });
            // sanity verify Bob himself is able to query for the chat thread from Bob's DWN
            const recordsQueryByBob = yield TestDataGenerator.generateRecordsQuery({
                author: bob,
                filter: { protocol }
            });
            const bobRecordsQueryReply = yield dwn.processMessage(bob.did, recordsQueryByBob.message);
            expect(bobRecordsQueryReply.status.code).to.equal(200);
            expect((_c = bobRecordsQueryReply.entries) === null || _c === void 0 ? void 0 : _c.length).to.equal(3);
            // sanity verify Alice herself is able to query for the chat message from Bob's DWN
            const recordsQueryByAlice = yield RecordsQuery.create({
                signer: Jws.createSigner(alice),
                protocolRole: 'thread/participant',
                filter: {
                    protocol,
                    contextId: threadRecord.message.contextId,
                    protocolPath: 'thread/chat'
                }
            });
            const aliceRecordsQueryReply = yield dwn.processMessage(bob.did, recordsQueryByAlice.message);
            expect(aliceRecordsQueryReply.status.code).to.equal(200);
            expect((_d = aliceRecordsQueryReply.entries) === null || _d === void 0 ? void 0 : _d.length).to.equal(1);
            // verify device X is able to query for the chat message from Bob's DWN
            const recordsQueryByDeviceX = yield RecordsQuery.create({
                signer: Jws.createSigner(deviceX),
                delegatedGrant: grantToDeviceX.asDelegatedGrant(),
                protocolRole: 'thread/participant',
                filter: {
                    protocol,
                    contextId: threadRecord.message.contextId,
                    protocolPath: 'thread/chat'
                }
            });
            const deviceXRecordsQueryReply = yield dwn.processMessage(bob.did, recordsQueryByDeviceX.message);
            expect(deviceXRecordsQueryReply.status.code).to.equal(200);
            expect((_e = deviceXRecordsQueryReply.entries) === null || _e === void 0 ? void 0 : _e.length).to.equal(1);
            // verify device X is able to read the chat message from Bob's DWN
            const recordsReadByDeviceX = yield RecordsRead.create({
                signer: Jws.createSigner(deviceX),
                delegatedGrant: grantToDeviceX.asDelegatedGrant(),
                protocolRole: 'thread/participant',
                filter: {
                    recordId: chatRecord.message.recordId
                }
            });
            const deviceXRecordsReadReply = yield dwn.processMessage(bob.did, recordsReadByDeviceX.message);
            expect(deviceXRecordsReadReply.status.code).to.equal(200);
            expect((_f = deviceXRecordsReadReply.record) === null || _f === void 0 ? void 0 : _f.recordId).to.equal(chatRecord.message.recordId);
            // Verify that Carol cannot query as Alice by invoking the delegated grant granted to Device X
            const recordsQueryByCarol = yield RecordsQuery.create({
                signer: Jws.createSigner(carol),
                delegatedGrant: grantToDeviceX.asDelegatedGrant(),
                protocolRole: 'thread/participant',
                filter: {
                    protocol,
                    contextId: threadRecord.message.contextId,
                    protocolPath: 'thread/chat'
                }
            });
            const recordsQueryByCarolReply = yield dwn.processMessage(bob.did, recordsQueryByCarol.message);
            expect(recordsQueryByCarolReply.status.code).to.equal(400);
            expect(recordsQueryByCarolReply.status.detail).to.contain(DwnErrorCode.RecordsValidateIntegrityGrantedToAndSignerMismatch);
            // Verify that Carol cannot read as Alice by invoking the delegated grant granted to Device X
            const recordsReadByCarol = yield RecordsRead.create({
                signer: Jws.createSigner(carol),
                delegatedGrant: grantToDeviceX.asDelegatedGrant(),
                protocolRole: 'thread/participant',
                filter: {
                    recordId: chatRecord.message.recordId
                }
            });
            const recordsReadByCarolReply = yield dwn.processMessage(bob.did, recordsReadByCarol.message);
            expect(recordsReadByCarolReply.status.code).to.equal(400);
            expect(recordsQueryByCarolReply.status.detail).to.contain(DwnErrorCode.RecordsValidateIntegrityGrantedToAndSignerMismatch);
        }));
        it('should only allow entity invoking a valid delegated grant to delete', () => __awaiter(this, void 0, void 0, function* () {
            var _g, _h;
            // scenario:
            // 1. Bob installs the chat protocol on his DWN and makes Alice an admin
            // 2. Bob starts a chat thread with Carol on his DWN
            // 3. Alice creates a delegated grant for Device X to act as her
            // 4. Carol should not be able to delete a chat message as Alice using Device X's delegated grant
            // 5. Device X should be able to delete a chat message as Alice
            const alice = yield DidKeyResolver.generate();
            const deviceX = yield DidKeyResolver.generate();
            const bob = yield DidKeyResolver.generate();
            const carol = yield DidKeyResolver.generate();
            // Bob has the chat protocol installed
            const protocolDefinition = threadRoleProtocolDefinition;
            const protocol = threadRoleProtocolDefinition.protocol;
            const protocolsConfig = yield TestDataGenerator.generateProtocolsConfigure({
                author: bob,
                protocolDefinition
            });
            const protocolsConfigureReply = yield dwn.processMessage(bob.did, protocolsConfig.message);
            expect(protocolsConfigureReply.status.code).to.equal(202);
            // Bob adds Alice as an admin
            const globalAdminRecord = yield TestDataGenerator.generateRecordsWrite({
                author: bob,
                recipient: alice.did,
                protocol: protocolDefinition.protocol,
                protocolPath: 'globalAdmin',
                data: new TextEncoder().encode('I trust Alice to manage my chat thread'),
            });
            const globalAdminRecordReply = yield dwn.processMessage(bob.did, globalAdminRecord.message, globalAdminRecord.dataStream);
            expect(globalAdminRecordReply.status.code).to.equal(202);
            // Bob starts a chat thread
            const threadRecord = yield TestDataGenerator.generateRecordsWrite({
                author: bob,
                protocol: protocolDefinition.protocol,
                protocolPath: 'thread',
            });
            const threadRoleReply = yield dwn.processMessage(bob.did, threadRecord.message, threadRecord.dataStream);
            expect(threadRoleReply.status.code).to.equal(202);
            // Bob adds Carol as a participant in the thread
            const participantRoleRecord = yield TestDataGenerator.generateRecordsWrite({
                author: bob,
                recipient: carol.did,
                protocol: protocolDefinition.protocol,
                protocolPath: 'thread/participant',
                contextId: threadRecord.message.contextId,
                parentId: threadRecord.message.recordId
            });
            const participantRoleReply = yield dwn.processMessage(bob.did, participantRoleRecord.message, participantRoleRecord.dataStream);
            expect(participantRoleReply.status.code).to.equal(202);
            // Carol writes a chat message in the thread
            const chatRecord = yield TestDataGenerator.generateRecordsWrite({
                author: carol,
                protocolRole: 'thread/participant',
                protocol: protocolDefinition.protocol,
                protocolPath: 'thread/chat',
                contextId: threadRecord.message.contextId,
                parentId: threadRecord.message.recordId,
                data: new TextEncoder().encode('A rude message'),
            });
            const chatRecordReply = yield dwn.processMessage(bob.did, chatRecord.message, chatRecord.dataStream);
            expect(chatRecordReply.status.code).to.equal(202);
            // Alice creates a delegated grant for device X to act as Alice.
            const scope = {
                interface: DwnInterfaceName.Records,
                method: DwnMethodName.Write,
                protocol
            };
            const grantToDeviceX = yield PermissionsGrant.create({
                delegated: true,
                dateExpires: Time.createOffsetTimestamp({ seconds: 100 }),
                description: 'Allow device X to write as me in chat protocol',
                grantedBy: alice.did,
                grantedTo: deviceX.did,
                grantedFor: alice.did,
                scope: scope,
                signer: Jws.createSigner(alice)
            });
            // verify Carol is not able to delete Carol's chat message from Bob's DWN
            const recordsDeleteByCarol = yield RecordsDelete.create({
                signer: Jws.createSigner(carol),
                delegatedGrant: grantToDeviceX.asDelegatedGrant(),
                protocolRole: 'thread/participant',
                recordId: chatRecord.message.recordId
            });
            const carolRecordsDeleteReply = yield dwn.processMessage(bob.did, recordsDeleteByCarol.message);
            expect(carolRecordsDeleteReply.status.code).to.equal(400);
            // sanity verify the chat message is still in Bob's DWN
            const recordsQueryByBob = yield TestDataGenerator.generateRecordsQuery({
                author: bob,
                filter: { protocolPath: 'thread/chat' }
            });
            const bobRecordsQueryReply = yield dwn.processMessage(bob.did, recordsQueryByBob.message);
            expect(bobRecordsQueryReply.status.code).to.equal(200);
            expect((_g = bobRecordsQueryReply.entries) === null || _g === void 0 ? void 0 : _g.length).to.equal(1);
            // verify device X is able to delete Carol's chat message from Bob's DWN
            const recordsDeleteByDeviceX = yield RecordsDelete.create({
                signer: Jws.createSigner(deviceX),
                delegatedGrant: grantToDeviceX.asDelegatedGrant(),
                protocolRole: 'globalAdmin',
                recordId: chatRecord.message.recordId
            });
            const deviceXRecordsDeleteReply = yield dwn.processMessage(bob.did, recordsDeleteByDeviceX.message);
            expect(deviceXRecordsDeleteReply.status.code).to.equal(202);
            // sanity verify the chat message is no longer queryable from Bob's DWN
            const bobRecordsQueryReply2 = yield dwn.processMessage(bob.did, recordsQueryByBob.message);
            expect(bobRecordsQueryReply2.status.code).to.equal(200);
            expect((_h = bobRecordsQueryReply2.entries) === null || _h === void 0 ? void 0 : _h.length).to.equal(0);
        }));
        xit('should not allow entity using a non-delegated grant as a delegated grant to invoke write', () => __awaiter(this, void 0, void 0, function* () {
        }));
        xit('should not allow entity using a non-delegated grant as a delegated grant to invoke read', () => __awaiter(this, void 0, void 0, function* () {
        }));
        xit('should not allow entity using a non-delegated grant as a delegated grant to invoke query', () => __awaiter(this, void 0, void 0, function* () {
        }));
        xit('should not allow entity using a non-delegated grant as a delegated grant to invoke delete', () => __awaiter(this, void 0, void 0, function* () {
        }));
        xit('should evaluate scoping correctly when invoking a delegated grant to write', () => __awaiter(this, void 0, void 0, function* () {
        }));
        xit('should evaluate scoping correctly when invoking a delegated grant to read', () => __awaiter(this, void 0, void 0, function* () {
        }));
        xit('should evaluate scoping correctly when invoking a delegated grant to query', () => __awaiter(this, void 0, void 0, function* () {
        }));
        xit('should evaluate scoping correctly when invoking a delegated grant to delete', () => __awaiter(this, void 0, void 0, function* () {
        }));
        xit('should not be able to create a RecordsWrite with a non-delegated grant assigned to `authorDelegatedGrant`', () => __awaiter(this, void 0, void 0, function* () {
        }));
        xit('should fail if presented with a delegated grant with invalid grantor signature', () => __awaiter(this, void 0, void 0, function* () {
        }));
        xit('should fail if presented with a delegated grant with mismatching grant ID in the payload of the message signature', () => __awaiter(this, void 0, void 0, function* () {
        }));
    }));
}
//# sourceMappingURL=delegated-grant.spec.js.map